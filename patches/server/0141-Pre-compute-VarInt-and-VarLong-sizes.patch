From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Mon, 21 Aug 2023 21:46:10 +0200
Subject: [PATCH] Pre-compute VarInt and VarLong sizes

License: GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html)
Gale - https://galemc.org

This patch is based on the following commit:
"Reapply "Optimize varint writing""
By: Andrew Steinborn <git@steinborn.me>
As part of: Velocity (https://github.com/PaperMC/Velocity)
Licensed under: GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html)

* Velocity description *

Inspired by the approach described at the bottom of https://richardstartin.github.io/posts/dont-use-protobuf-for-telemetry

Given that we do a lot of varint writing as well, this should provide a small performance boost for larger/complex packets whilst not regressing hard on smaller packets.

This includes a test to ensure that the behavior is as expected and fixes the initialization loop so that the correct results will be given. Much thanks to @octylFractal for acting as my duck while trying to figure this out.

diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index 9938bb90bef84cf784f9a1ceb02a1a45aa8b48a1..c37d1a3cae9063a8cbc84b6420a7f89d650a874e 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -102,7 +102,28 @@ public class FriendlyByteBuf extends ByteBuf {
         this.source = parent;
     }
 
+    // Gale start - Velocity - pre-compute VarInt and VarLong sizes
+    private static final int[] VARINT_EXACT_BYTE_LENGTHS = new int[33];
+    private static final int[] VARLONG_EXACT_BYTE_LENGTHS = new int[65];
+    static {
+        for (int i = 0; i < 32; ++i) {
+            VARINT_EXACT_BYTE_LENGTHS[i] = (32 - i + 6) / 7;
+        }
+        VARINT_EXACT_BYTE_LENGTHS[32] = 1; // Special case for the number 0.
+        for (int i = 0; i < 64; ++i) {
+            VARLONG_EXACT_BYTE_LENGTHS[i] = (64 - i + 6) / 7;
+        }
+        VARLONG_EXACT_BYTE_LENGTHS[64] = 1; // Special case for the number 0.
+    }
+    // Gale end - Velocity - pre-compute VarInt and VarLong sizes
+
     public static int getVarIntSize(int value) {
+        // Gale start - Velocity - pre-compute VarInt and VarLong sizes
+        return VARINT_EXACT_BYTE_LENGTHS[Integer.numberOfLeadingZeros(value)];
+    }
+
+    static int getVarIntSizeOriginal(int value) { // public -> package-private
+        // Gale end - Velocity - pre-compute VarInt and VarLong sizes
         for (int j = 1; j < 5; ++j) {
             if ((value & -1 << j * 7) == 0) {
                 return j;
@@ -113,6 +134,12 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public static int getVarLongSize(long value) {
+        // Gale start - Velocity - pre-compute VarInt and VarLong sizes
+        return VARLONG_EXACT_BYTE_LENGTHS[Long.numberOfLeadingZeros(value)];
+    }
+
+    static int getVarLongSizeOriginal(long value) { // public -> package-private
+        // Gale end - Velocity - pre-compute VarInt and VarLong sizes
         for (int j = 1; j < 10; ++j) {
             if ((value & -1L << j * 7) == 0L) {
                 return j;
diff --git a/src/test/java/net/minecraft/network/FriendlyByteBufTest.java b/src/test/java/net/minecraft/network/FriendlyByteBufTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..e529888932a88e4876a3287ac7ebe8ad2bf77513
--- /dev/null
+++ b/src/test/java/net/minecraft/network/FriendlyByteBufTest.java
@@ -0,0 +1,159 @@
+// Gale - Velocity - VarInt and VarLong optimizations
+
+package net.minecraft.network;
+
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class FriendlyByteBufTest {
+
+    private static String padStringWithLeadingZeros(String string, int length) {
+        if (string.length() >= length) {
+            return string;
+        }
+        return "0".repeat(length - string.length()) + string;
+    }
+
+    private static final IntSet integerCases;
+    static {
+        integerCases = new IntOpenHashSet();
+        {
+            integerCases.add(0);
+            integerCases.add(-1);
+        }
+        {
+            for (int i = 0; i < 32; i++) {
+                integerCases.add(1 << i);
+            }
+        }
+        {
+            for (int factor = 1; factor <= 7; factor++) {
+                int all = 0;
+                for (int i = 0; i <= 4; i++) {
+                    int shifted = 1 << (i * factor);
+                    all |= shifted;
+                    integerCases.add(shifted);
+                    integerCases.add(shifted - 1);
+                    integerCases.add(~shifted);
+                    integerCases.add(-shifted);
+                    integerCases.add((~shifted) & (0x80000000));
+                    integerCases.add(all);
+                    integerCases.add(all - 1);
+                    integerCases.add(~all);
+                    integerCases.add(-all);
+                    integerCases.add((~all) & (0x80000000));
+                }
+            }
+        }
+        {
+            var newCases = new IntOpenHashSet();
+            for (int shiftSize = 2; shiftSize <= 6; shiftSize++) {
+                for (int offset = 0; offset < shiftSize; offset++) {
+                    int striped = 0;
+                    for (int i = offset; i < 32; i += shiftSize) {
+                        striped |= 1 << i;
+                    }
+                    final var finalStriped = striped;
+                    integerCases.forEach(existing -> {
+                        newCases.add(existing | finalStriped);
+                        newCases.add(existing | (~finalStriped));
+                        newCases.add(existing & finalStriped);
+                        newCases.add(existing & (~finalStriped));
+                        newCases.add(existing - finalStriped);
+                        newCases.add(existing - (~finalStriped));
+                    });
+                }
+            }
+            integerCases.addAll(newCases);
+        }
+    }
+
+    private static final LongSet longCases;
+    static {
+        longCases = new LongOpenHashSet();
+        {
+            longCases.add(0);
+            longCases.add(-1);
+        }
+        {
+            for (int i = 0; i < 64; i++) {
+                longCases.add(1L << i);
+            }
+        }
+        {
+            for (int factor = 1; factor <= 7; factor++) {
+                long all = 0;
+                for (int i = 0; i <= 9; i++) {
+                    long shifted = 1L << (i * factor);
+                    all |= shifted;
+                    longCases.add(shifted);
+                    longCases.add(shifted - 1);
+                    longCases.add(~shifted);
+                    longCases.add(-shifted);
+                    longCases.add((~shifted) & (0x8000000000000000L));
+                    longCases.add(all);
+                    longCases.add(all - 1);
+                    longCases.add(~all);
+                    longCases.add(-all);
+                    longCases.add((~all) & (0x8000000000000000L));
+                }
+            }
+        }
+        {
+            var newCases = new LongOpenHashSet();
+            for (int shiftSize = 2; shiftSize <= 6; shiftSize++) {
+                for (int offset = 0; offset < shiftSize; offset++) {
+                    long striped = 0;
+                    for (int i = offset; i < 64; i += shiftSize) {
+                        striped |= 1L << i;
+                    }
+                    final var finalStriped = striped;
+                    longCases.forEach(existing -> {
+                        newCases.add(existing | finalStriped);
+                        newCases.add(existing | (~finalStriped));
+                        newCases.add(existing & finalStriped);
+                        newCases.add(existing & (~finalStriped));
+                        newCases.add(existing - finalStriped);
+                        newCases.add(existing - (~finalStriped));
+                    });
+                }
+            }
+            longCases.addAll(newCases);
+        }
+    }
+
+    // Gale start - Velocity - pre-compute VarInt and VarLong sizes
+    @Test
+    public void testGetVarIntSizeComparedToOriginal() {
+        integerCases.forEach(value -> {
+            // given
+            int originalSize = FriendlyByteBuf.getVarIntSizeOriginal(value);
+
+            // when
+            int size = FriendlyByteBuf.getVarIntSize(value);
+
+            // then
+            Assert.assertEquals("Optimized size (" + size + ") is not equal to original size (" + originalSize + ") for test case value " + value + " (binary: " + padStringWithLeadingZeros(Integer.toBinaryString(value), 32) + ")", originalSize, size);
+        });
+    }
+
+    @Test
+    public void testGetVarLongSizeComparedToOriginal() {
+        longCases.forEach(value -> {
+            // given
+            int originalSize = FriendlyByteBuf.getVarLongSizeOriginal(value);
+
+            // when
+            int size = FriendlyByteBuf.getVarLongSize(value);
+
+            // then
+            Assert.assertEquals("Optimized size (" + size + ") is not equal to original size (" + originalSize + ") for test case value " + value + " (binary: " + padStringWithLeadingZeros(Long.toBinaryString(value), 64) + ")", originalSize, size);
+        });
+    }
+    // Gale end - Velocity - pre-compute VarInt and VarLong sizes
+
+}
